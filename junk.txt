# An old version of the lu_fact method
def lu_fact(matrix):
    lMatrixQueue = Queue.Queue()
    rowIndex = 0
    colIndex = 0
    identityMatrix = np.identity(matrix.shape[0])
    while (rowIndex < matrix.shape[1]):
        if matrix[rowIndex, colIndex] != 0:
            currentLMatrix = identityMatrix
            if matrix[rowIndex, colIndex] != 1:
                currentLMatrix[rowIndex, :] = currentLMatrix[rowIndex, :] / matrix[rowIndex, colIndex]
                lMatrixQueue.put(currentLMatrix)

            for currentRow in range(rowIndex + 1, matrix.shape[0]):
                if matrix[currentRow, colIndex] > 0:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] - currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                else:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] + currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                currentLMatrix[currentRow, colIndex] = -currentLMatrix[currentRow, colIndex] #Changing the sign of the item so that we don't need to take the inverse later.
                lMatrixQueue.put(currentLMatrix)
        rowIndex = rowIndex + 2
        colIndex = colIndex + 2
    lMatrix = lMatrixQueue.get()
    for currentMatrix in range(1, lMatrixQueue.qsize()):
        lMatrix = multiplyMatrices(lMatrix, lMatrixQueue.get())
    print lMatrix



#old multiply:
def multiplyMatrices(matrix1, matrix2):
    matrix3 = np.zeros(shape=(matrix1.shape[0], matrix2.shape[1]))
    if matrix1.shape[1] != matrix2.shape[0]:
        print "Cannot multiply these matrices"
        return
    elif matrix1.shape[1] == 1 and matrix2.shape[0] == 1:
        for rowIndex in range(0, matrix1.shape[0]):
            for colIndex in range(0, matrix1.shape[0]):
                matrix3[rowIndex, colIndex] = np.dot(matrix1[rowIndex, 0], matrix2[0, colIndex])
    elif matrix1.shape[0] == 1 and matrix2.shape[1] == 1:
                matrix3 = np.dot(matrix1, matrix2)
    else:
        for rowIndex in range(0, matrix1.shape[0]):
            for colIndex in range(0, matrix1.shape[1]):
                matrix3[rowIndex, colIndex] = np.dot(matrix1[rowIndex, :], matrix2[:, colIndex])
    return matrix3
