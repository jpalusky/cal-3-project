# An old version of the lu_fact method
def lu_fact(matrix):
    lMatrixQueue = Queue.Queue()
    rowIndex = 0
    colIndex = 0
    identityMatrix = np.identity(matrix.shape[0])
    while (rowIndex < matrix.shape[1]):
        if matrix[rowIndex, colIndex] != 0:
            currentLMatrix = identityMatrix
            if matrix[rowIndex, colIndex] != 1:
                currentLMatrix[rowIndex, :] = currentLMatrix[rowIndex, :] / matrix[rowIndex, colIndex]
                lMatrixQueue.put(currentLMatrix)

            for currentRow in range(rowIndex + 1, matrix.shape[0]):
                if matrix[currentRow, colIndex] > 0:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] - currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                else:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] + currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                currentLMatrix[currentRow, colIndex] = -currentLMatrix[currentRow, colIndex] #Changing the sign of the item so that we don't need to take the inverse later.
                lMatrixQueue.put(currentLMatrix)
        rowIndex = rowIndex + 2
        colIndex = colIndex + 2
    lMatrix = lMatrixQueue.get()
    for currentMatrix in range(1, lMatrixQueue.qsize()):
        lMatrix = multiplyMatrices(lMatrix, lMatrixQueue.get())
    print lMatrix



#old multiply:
def multiplyMatrices(matrix1, matrix2):
    matrix3 = np.zeros(shape=(matrix1.shape[0], matrix2.shape[1]))
    if matrix1.shape[1] != matrix2.shape[0]:
        print "Cannot multiply these matrices"
        return
    elif matrix1.shape[1] == 1 and matrix2.shape[0] == 1:
        for rowIndex in range(0, matrix1.shape[0]):
            for colIndex in range(0, matrix1.shape[0]):
                matrix3[rowIndex, colIndex] = np.dot(matrix1[rowIndex, 0], matrix2[0, colIndex])
    elif matrix1.shape[0] == 1 and matrix2.shape[1] == 1:
                matrix3 = np.dot(matrix1, matrix2)
    else:
        for rowIndex in range(0, matrix1.shape[0]):
            for colIndex in range(0, matrix1.shape[1]):
                matrix3[rowIndex, colIndex] = np.dot(matrix1[rowIndex, :], matrix2[:, colIndex])
    return matrix3


def solve_paschal_lu():
    for n in range(2, 13):
        matrixA = form_paschal_matrix(n)
        matrixB = form_b_matrix(n)
        result = solve_lu_b(matrixA, np.copy(matrixB))
        errorLU = util.matrix_max_norm(result[1] - matrixA)
        errorP = util.matrix_max_norm(multiplyMatrices(matrixA, result[0]) - matrixB)
        print "n = " + str(n)
        print "X solution:"
        print result[0]
        print "LU-P error"
        print errorLU
        print "Px-b error"
        print errorP
        print "\n"

def solve_paschal_givens():
    for n in range(2, 13):
        matrixA = form_paschal_matrix(n)
        matrixB = form_b_matrix(n)
        result = solve_qr_b(matrixA, np.copy(matrixB))
        errorQR = util.matrix_max_norm(result[1] - matrixA)
        errorP = util.matrix_max_norm(multiplyMatrices(matrixA, result[0]) - matrixB)
        print "n = " + str(n)
        print "X solution:"
        print result[0]
        print "QR-P error"
        print errorQR
        print "Px-b error"
        print errorP
        print "\n"

def solve_paschal_househ():
    for n in range(2, 13):
        matrixA = form_paschal_matrix(n)
        matrixB = form_b_matrix(n)
        result = solve_househ_b(matrixA, np.copy(matrixB))
        errorQR = util.matrix_max_norm(result[1] - matrixA)
        errorP = util.matrix_max_norm(multiplyMatrices(matrixA, result[0]) - matrixB)
        print "n = " + str(n)
        print "X solution:"
        print result[0]
        print "QR-P error"
        print errorQR
        print "Px-b error"
        print errorP
        print "\n"