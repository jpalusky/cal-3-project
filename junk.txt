# An old version of the lu_fact method
def lu_fact(matrix):
    lMatrixQueue = Queue.Queue()
    rowIndex = 0
    colIndex = 0
    identityMatrix = np.identity(matrix.shape[0])
    while (rowIndex < matrix.shape[1]):
        if matrix[rowIndex, colIndex] != 0:
            currentLMatrix = identityMatrix
            if matrix[rowIndex, colIndex] != 1:
                currentLMatrix[rowIndex, :] = currentLMatrix[rowIndex, :] / matrix[rowIndex, colIndex]
                lMatrixQueue.put(currentLMatrix)

            for currentRow in range(rowIndex + 1, matrix.shape[0]):
                if matrix[currentRow, colIndex] > 0:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] - currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                else:
                    currentLMatrix[currentRow, :] = currentLMatrix[currentRow, :] + currentLMatrix[rowIndex, :]*matrix[currentRow, colIndex]
                currentLMatrix[currentRow, colIndex] = -currentLMatrix[currentRow, colIndex] #Changing the sign of the item so that we don't need to take the inverse later.
                lMatrixQueue.put(currentLMatrix)
        rowIndex = rowIndex + 2
        colIndex = colIndex + 2
    lMatrix = lMatrixQueue.get()
    for currentMatrix in range(1, lMatrixQueue.qsize()):
        lMatrix = multiplyMatrices(lMatrix, lMatrixQueue.get())
    print lMatrix


